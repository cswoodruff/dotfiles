#Module Template
snippet module create verilog template file
	//----------------------------------------------------------------------------//
	//
	//  $Id: $1.v 89 2010-06-02 00:59:40Z cwoodruf $
	//
	//  MODULE NAME(S):             ${1:module_name}
	//
	//  SUBMODULE DEPENDENCIES:     
	//
	//  AUTHOR:                     ${2:author_name}
	//
	//  DESCRIPTION:
	//
	//  PARAMETERS:
	//
	//  REGISTERS:
	//
	//----------------------------------------------------------------------------//
	
	`ifndef _$1
	`define _$1

	module $1 (
		${3:io_ports)
	);

	//----------------------------------------------//
	//
	//    PARAMETERS
	//
	//----------------------------------------------//

	//----------------------------------------------//
	//
	//    I/O DECLARATION
	//
	//----------------------------------------------//
	$3

	//----------------------------------------------//
	//
	//    Internal Signal Declaration
	//
	//----------------------------------------------//

	//----------------------------------------------//
	//
	//    Logic
	//
	//----------------------------------------------//

	//----------------------------------------------//
	//
	//    SUBMODULES
	//
	//----------------------------------------------//

	//----------------------------------------------//
	//
	//    OUTPUTS
	//
	//----------------------------------------------//

	endmodule

	`endif
#Input
snippet in
	input ${1}${2:input_name};
#Output
snippet out
	output ${1}${2:output_name};
#Wire declaration
snippet w wire declaration
	wire [${1:31}:0] ${2:wire_name};
#Reg declaration
snippet r reg declaration
	reg [${1:31}:0] ${2:wire_name};
#Assign statement
snippet a assign statement
	assign ${1:wire_name} = ${2:wire_value};
#Register with Asynchronous Reset
snippet reg register with asynchronous reset
	always @(posedge ${1:i_clk} or posedge ${2:i_reset}) begin
		if($2)
			${3:reg_name} <= 'b0;
		else
			$3 <= ${4:new_value};
	end
#Multiplexors
snippet mux case statement style multiplexor
	always @(*) begin
		case(${1:select})
			${2}
		endcase
	end
snippet ter ternary operator style multiplexor
	assign ${1:output} = (${2:select}) ? ${3:true} : ${4:false};
#Simple Up Counter
snippet cnt simple up counter
	always @(posedge ${1:i_clk} or posedge ${2:i_reset}) begin
		if($2)
			${3:counter} <= 'b0;
		else
			$3 <= $3 + ${4:increment_value};
	end
#Conditional Counter
snippet ccnt conditional up counter
	always @(posedge ${1:i_clk} or posedge ${2:i_reset}) begin
		if($2)
			${3:counter} <= 'b0;
		else if(${4:increment_condition})
			$3 <= $3 + ${5:increment_value};
	end
#Accumulator
snippet accum simple accumulator with synchronous reset
	always @(posedge ${1:i_clk}) begin
		if(${2:i_reset})
			${3:accum_reg} <= 'b0;
		else if(${4:enable})
			$3 <= $3 + ${5:increment_value};
	end
#Finite State Machine
snippet fsm finite state machine
	// FSM State Declarations
	parameter [${1:number_states}:0]	${3:STATE0}	= ${2:'h}1,
										${4:STATE1}	= $2 2,
										${5:STATE2}	= $2 4,
										${6:STATE3}	= $2 8;
	reg [$1:0] state, next_state;
	
	// FSM Current State Register	
	always @(posedge ${7:i_clk} or posedge ${8:i_reset})
		if($8)	state <= $3;
		else	state <= next_state;

	// FSM Next State Logic
	always @(*) begin
		next_state = state;
		case(state)
			$3:			next_state = $4; 
			$4:			next_state = $5;
			$5:			next_state = $6;
			$6:			next_state = $4;
			default:	next_state = $4;
		endcase
	end
